<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>Admin</title>
    <style>
      body {
        font-family: Arial, Helvetica, sans-serif;
        margin: 2rem;
        display: flex;
        flex-direction: column;
        gap: 1.5rem;
        background: #f8fafc;
      }
      a,
      button {
        width: fit-content;
        padding: 0.5rem 1rem;
        border-radius: 999px;
        border: none;
        background: #1f4ad1;
        color: #fff;
        cursor: pointer;
        font-weight: 600;
        text-decoration: none;
        display: inline-flex;
        align-items: center;
        justify-content: center;
        gap: 0.35rem;
      }
      a:hover,
      button:hover {
        background: #1739a2;
      }
      table {
        border-collapse: collapse;
        width: 100%;
        background: #fff;
        border-radius: 12px;
        overflow: hidden;
        box-shadow: 0 10px 40px rgba(15, 23, 42, 0.08);
      }
      th,
      td {
        border: 1px solid #cbd2d9;
        padding: 0.75rem;
        text-align: left;
      }
      select {
        padding: 0.35rem 0.5rem;
      }
      th {
        background: #f4f6fb;
      }
      .actions {
        display: flex;
        gap: 0.5rem;
      }
      form.inline {
        display: inline;
      }
      section {
        display: flex;
        flex-direction: column;
        gap: 0.5rem;
      }
      section + section {
        margin-top: 1rem;
      }
      .chat-alert {
        background: #fff;
        border-radius: 16px;
        padding: 1.25rem 1.5rem;
        box-shadow: 0 15px 35px rgba(15, 23, 42, 0.06);
        display: flex;
        flex-wrap: wrap;
        align-items: center;
        justify-content: space-between;
        gap: 1rem;
      }
      .chat-alert button:disabled {
        background: #cbd2d9;
        cursor: not-allowed;
      }
      .empty-state {
        color: #6b7280;
      }
      .booking-admin {
        background: #fff;
        border-radius: 16px;
        padding: 1.5rem;
        box-shadow: 0 15px 40px rgba(15, 23, 42, 0.08);
        display: flex;
        flex-direction: column;
        gap: 1rem;
      }
      .slot-form {
        display: grid;
        grid-template-columns: repeat(auto-fit, minmax(220px, 1fr));
        gap: 1rem;
        align-items: end;
      }
      .slot-form label {
        display: flex;
        flex-direction: column;
        gap: 0.35rem;
        font-weight: 600;
        color: #475569;
      }
      .slot-form input[type="date"] {
        padding: 0.45rem 0.6rem;
        border-radius: 10px;
        border: 1px solid #cbd2d9;
      }
      .time-picker__options {
        display: flex;
        flex-wrap: wrap;
        gap: 0.5rem;
        margin-top: 0.5rem;
      }
      .time-button {
        background: #e2e8f0;
        color: #0f172a;
        border-radius: 999px;
        padding: 0.35rem 0.85rem;
        cursor: pointer;
        border: none;
        font-weight: 600;
      }
      .time-button.selected {
        background: #1f4ad1;
        color: #fff;
      }
      .slot-columns {
        display: grid;
        grid-template-columns: repeat(auto-fit, minmax(280px, 1fr));
        gap: 1rem;
      }
      .slot-list {
        list-style: none;
        margin: 0;
        padding: 0;
        display: flex;
        flex-direction: column;
        gap: 0.65rem;
      }
      .slot-list li {
        padding: 0.9rem 1rem;
        border-radius: 12px;
        border: 1px solid #e2e8f0;
        background: #f8fafc;
      }
      .slot-list strong {
        display: block;
        font-size: 1rem;
        margin-bottom: 0.2rem;
      }
      .muted {
        color: #64748b;
        font-size: 0.9rem;
      }
      .slots-table {
        border-collapse: collapse;
        width: 100%;
        background: #fff;
        border-radius: 12px;
        overflow: hidden;
      }
      .slots-table th,
      .slots-table td {
        border: 1px solid #e2e8f0;
        padding: 0.75rem;
        text-align: left;
      }
      .slots-table th {
        background: #f8fafc;
      }
      .slot-status-form select {
        padding: 0.35rem 0.5rem;
        border-radius: 8px;
        border: 1px solid #cbd2d9;
      }
      .chat-panel {
        background: #fff;
        border-radius: 16px;
        padding: 1.5rem;
        box-shadow: 0 20px 50px rgba(15, 23, 42, 0.08);
        display: flex;
        flex-direction: column;
        gap: 1rem;
      }
      .chat-panel__header {
        display: flex;
        justify-content: space-between;
        align-items: center;
        gap: 1rem;
      }
      .chat-panel__actions {
        display: flex;
        align-items: flex-start;
        gap: 0.75rem;
        flex-wrap: wrap;
      }
      .chat-panel__selection-group {
        display: flex;
        gap: 0.75rem;
        flex-wrap: wrap;
        align-items: flex-end;
      }
      .chat-panel__selection {
        display: flex;
        flex-direction: column;
        gap: 0.25rem;
        min-width: 220px;
      }
      .chat-panel__selection label {
        font-size: 0.85rem;
        font-weight: 600;
        color: #475569;
      }
      .chat-panel__selection select {
        padding: 0.4rem 0.5rem;
        border-radius: 8px;
        border: 1px solid #cbd2d9;
        font-size: 0.95rem;
        min-height: 2.25rem;
      }
      .chat-indicator {
        padding: 0.35rem 0.75rem;
        border-radius: 999px;
        background: #e2e8f0;
        color: #1f2937;
        font-size: 0.85rem;
        font-weight: 600;
        transition: transform 0.2s ease, background 0.2s ease;
      }
      .chat-indicator.active {
        background: #f97316;
        color: #fff;
        animation: pulse 1s infinite;
      }
      @keyframes pulse {
        0% {
          transform: scale(1);
        }
        50% {
          transform: scale(1.08);
        }
        100% {
          transform: scale(1);
        }
      }
      .chat-panel__close {
        background: #e2e8f0;
        color: #0f172a;
      }
      .chat-panel__close:hover {
        background: #cbd2d9;
        color: #0f172a;
      }
      .chat-panel__body {
        max-height: 380px;
        height: 380px;
        overflow-y: auto;
        display: flex;
        flex-direction: column;
        gap: 0.65rem;
        border: 1px solid #e2e8f0;
        border-radius: 12px;
        padding: 1rem;
        background: #f8fafc;
      }
      .chat-row {
        display: flex;
      }
      .chat-row.admin {
        justify-content: flex-end;
      }
      .chat-row .bubble {
        padding: 0.6rem 0.85rem;
        border-radius: 12px;
        max-width: 70%;
        font-size: 0.95rem;
      }
      .chat-row.admin .bubble {
        background: #1f4ad1;
        color: #fff;
        border-bottom-right-radius: 4px;
      }
      .chat-row.visitor .bubble {
        background: #fff;
        border: 1px solid #e2e8f0;
        color: #0f172a;
        border-bottom-left-radius: 4px;
      }
      .chat-panel__form {
        display: flex;
        gap: 0.75rem;
        align-items: center;
      }
      .chat-panel__form input {
        flex: 1;
        padding: 0.55rem 0.9rem;
        border-radius: 999px;
        border: 1px solid #cbd2d9;
        font-size: 1rem;
      }
      .chat-panel__form button {
        margin: 0;
        border-radius: 999px;
      }
      .chat-empty-state {
        width: 100%;
        text-align: center;
        color: #6b7280;
        padding: 1.5rem 0.5rem;
      }
      .hidden {
        display: none;
      }
      .chat-alert.flash {
        animation: flashBg 1s steps(2, jump-start) infinite;
      }
      .chat-panel__delete {
        background: #fee2e2;
        color: #991b1b;
      }
      .chat-panel__delete:hover {
        background: #fecaca;
        color: #7f1d1d;
      }
      .chat-panel__delete:disabled {
        background: #e2e8f0;
        color: #475569;
        cursor: not-allowed;
      }
      @keyframes flashBg {
        0% {
          box-shadow: 0 0 0 rgba(249, 115, 22, 0.3);
          background: #fff7ed;
        }
        50% {
          box-shadow: 0 0 25px rgba(249, 115, 22, 0.45);
          background: #ffedd5;
        }
        100% {
          box-shadow: 0 0 0 rgba(249, 115, 22, 0.3);
          background: #fff7ed;
        }
      }
    </style>
  </head>
  <body>
    <h1>Admin Page</h1>
    <a href="{{ home_url }}">Return to Home</a>
    <section>
      <h2>Enquiries</h2>
      {% if submissions %}
      <table>
        <thead>
          <tr>
            <th>Name</th>
            <th>Email</th>
            <th>Phone</th>
            <th>Message</th>
            <th>Status</th>
            <th>Actions</th>
          </tr>
        </thead>
        <tbody>
          {% for submission in submissions %}
          <tr>
            <td>{{ submission.name }}</td>
            <td>{{ submission.email }}</td>
            <td>{{ submission.phone }}</td>
            <td>{{ submission.message }}</td>
            <td>
              <form
                class="inline"
                method="post"
                action="{{ url_for('update_submission_status', submission_id=submission.id) }}"
              >
                <select name="status" onchange="this.form.submit()">
                  {% for option in status_options %}
                  <option value="{{ option }}" {% if option == (submission.status or 'New') %}selected{% endif %}>
                    {{ option }}
                  </option>
                  {% endfor %}
                </select>
                <noscript>
                  <button type="submit">Update</button>
                </noscript>
              </form>
            </td>
            <td>
              <div class="actions">
                <a href="{{ url_for('edit_submission', submission_id=submission.id) }}">Edit</a>
                <form
                  class="inline"
                  method="post"
                  action="{{ url_for('delete_submission', submission_id=submission.id) }}"
                >
                  <button type="submit">Delete</button>
                </form>
              </div>
            </td>
          </tr>
          {% endfor %}
        </tbody>
      </table>
      {% else %}
      <p class="empty-state">
        No submissions yet. Head back to the <a href="{{ home_url }}">home page</a> to create one.
      </p>
      {% endif %}
    </section>

    <section class="booking-admin">
      <div>
        <h2>Appointment slots</h2>
        <p style="margin: 0; color: #475569">Publish dates and times visitors can book instantly.</p>
      </div>
      <form class="slot-form" method="post" action="{{ url_for('create_appointment_slot') }}">
        <label>
          Pick a date
          <input type="date" name="date" min="{{ today }}" required />
        </label>
        <div>
          <span style="font-weight: 600; color: #475569">Choose a time</span>
          <input
            type="hidden"
            name="time"
            id="slotTimeInput"
            value="{{ time_choices[0] if time_choices else '' }}"
            required
          />
          <div class="time-picker__options">
            {% for option in time_choices %}
            <button
              type="button"
              class="time-button {% if loop.first %}selected{% endif %}"
              data-time-option="{{ option }}"
            >
              {{ option }}
            </button>
            {% endfor %}
          </div>
        </div>
        <button type="submit">Add slot</button>
      </form>
      <div class="slot-columns">
        <div>
          <h3>Available slots</h3>
          {% if available_slots %}
          <ul class="slot-list">
            {% for slot in available_slots %}
            <li>
              <strong>{{ slot.long_date_label }}</strong>
              <span class="muted">{{ slot.time_label }}</span>
            </li>
            {% endfor %}
          </ul>
          {% else %}
          <p class="empty-state">No open slots at the moment.</p>
          {% endif %}
        </div>
        <div>
          <h3>Booked slots</h3>
          {% if booked_slots %}
          <table class="slots-table">
            <thead>
              <tr>
                <th>When</th>
                <th>Visitor</th>
                <th>Status</th>
              </tr>
            </thead>
            <tbody>
              {% for slot in booked_slots %}
              <tr>
                <td>
                  <strong>{{ slot.long_date_label }}</strong>
                  <div class="muted">{{ slot.time_label }}</div>
                </td>
                <td>
                  <div>{{ slot.visitor_name or '—' }}</div>
                  <div class="muted">{{ slot.visitor_email or '—' }}</div>
                </td>
                <td>
                  <form
                    class="slot-status-form"
                    method="post"
                    action="{{ url_for('update_slot_status', slot_id=slot.id) }}"
                  >
                    <select name="status" onchange="this.form.submit()">
                      {% for option in booking_status_options %}
                      <option value="{{ option }}" {% if option == (slot.workflow_status or 'New') %}selected{% endif %}>
                        {{ option }}
                      </option>
                      {% endfor %}
                    </select>
                    <noscript><button type="submit">Update</button></noscript>
                  </form>
                </td>
              </tr>
              {% endfor %}
            </tbody>
          </table>
          {% else %}
          <p class="empty-state">Booked slots will appear here as visitors reserve them.</p>
          {% endif %}
        </div>
      </div>
    </section>

    <script>
      (function () {
        const timeButtons = document.querySelectorAll("[data-time-option]");
        const timeInput = document.getElementById("slotTimeInput");
        if (!timeInput || !timeButtons.length) {
          return;
        }
        function select(button) {
          timeButtons.forEach((btn) => btn.classList.toggle("selected", btn === button));
          timeInput.value = button.dataset.timeOption || "";
        }
        const defaultButton = Array.from(timeButtons).find((btn) => btn.dataset.timeOption);
        if (defaultButton) {
          select(defaultButton);
        }
        timeButtons.forEach((button) => {
          button.addEventListener("click", () => select(button));
        });
      })();
    </script>

    <section>
      <h2>Visitor Insights</h2>
      {% if visitors %}
      <table>
        <thead>
          <tr>
            <th>IP Address</th>
            <th>Visits</th>
            <th>First Visit (UTC)</th>
            <th>Last Visit (UTC)</th>
            <th>Location</th>
            <th>User Agent</th>
            <th>Accept-Language</th>
            <th>Actions</th>
          </tr>
        </thead>
        <tbody>
          {% for ip, details in visitors %}
          <tr>
            <td>{{ ip }}</td>
            <td>{{ details.visits }}</td>
            <td>{{ details.first_visit.strftime('%Y-%m-%d %H:%M:%S') }}</td>
            <td>{{ details.last_visit.strftime('%Y-%m-%d %H:%M:%S') }}</td>
            <td>{{ details.location }}</td>
            <td>{{ details.user_agent }}</td>
            <td>{{ details.accept_language }}</td>
            <td>
              {% if ip in blocked_ips %}
              <form class="inline" method="post" action="{{ url_for('unblock_visitor', ip_address=ip) }}">
                <button type="submit">Unblock</button>
              </form>
              {% else %}
              <form class="inline" method="post" action="{{ url_for('block_visitor', ip_address=ip) }}">
                <button type="submit">Block</button>
              </form>
              {% endif %}
            </td>
          </tr>
          {% endfor %}
        </tbody>
      </table>
      {% else %}
      <p class="empty-state">No visitor data collected yet.</p>
      {% endif %}
    </section>

    <section class="chat-alert">
      <div>
        <h2>Live Visitor Chat</h2>
        <p id="chatStatusMessage" style="margin: 0; color: #475569">
          {% if chat_waiting_count > 1 %}
          There are {{ chat_waiting_count }} visitors waiting to chat.
          {% elif chat_waiting_count == 1 %}
          A visitor is waiting to chat.
          {% elif chat_has_conversations %}
          No visitors are currently waiting.
          {% else %}
          No live conversations yet.
          {% endif %}
        </p>
      </div>
      <button id="openChatButton" {% if not chat_has_conversations %}disabled{% endif %}>
        Open chat window
      </button>
    </section>

    <section class="chat-panel hidden" id="chatPanel">
      <div class="chat-panel__header">
        <div>
          <h2>Live Visitor Chat</h2>
          <p style="margin: 0; color: #475569">Reply in real time to site visitors.</p>
        </div>
        <div class="chat-panel__actions">
          <div class="chat-panel__selection-group">
            <div class="chat-panel__selection">
              <label for="chatVisitorSelect">Visitor conversation</label>
              <select id="chatVisitorSelect" {% if not chat_has_conversations %}disabled{% endif %}>
                <option value="">
                  {% if chat_has_conversations %}Select a visitor{% else %}No conversations yet{% endif %}
                </option>
              </select>
            </div>
            <button
              type="button"
              class="chat-panel__delete"
              id="deleteConversationButton"
              {% if not chat_has_conversations %}disabled{% endif %}
            >
              Delete conversation
            </button>
          </div>
          <span id="chatIndicator" class="chat-indicator {% if chat_unread %}active{% endif %}">
            {% if chat_unread %}New message{% else %}All caught up{% endif %}
          </span>
          <button type="button" class="chat-panel__close" id="closeChatButton">Close</button>
        </div>
      </div>
      <div class="chat-panel__body" id="adminChatMessages" aria-live="polite"></div>
      <form class="chat-panel__form" id="adminChatForm">
        <input
          type="text"
          id="adminChatInput"
          autocomplete="off"
          placeholder="Write a friendly reply..."
          required
        />
        <button type="submit">Send</button>
      </form>
    </section>
    <script>
      const initialConversations = {{ chat_conversations | tojson }};
      (function () {
        const messagesEl = document.getElementById("adminChatMessages");
        const form = document.getElementById("adminChatForm");
        const input = document.getElementById("adminChatInput");
        const submitButton = form ? form.querySelector("button[type='submit']") : null;
        const indicator = document.getElementById("chatIndicator");
        const panel = document.getElementById("chatPanel");
        const statusMessage = document.getElementById("chatStatusMessage");
        const openButton = document.getElementById("openChatButton");
        const closeButton = document.getElementById("closeChatButton");
        const chatAlert = document.querySelector(".chat-alert");
        const conversationSelect = document.getElementById("chatVisitorSelect");
        const deleteButton = document.getElementById("deleteConversationButton");
        const AudioContext = window.AudioContext || window.webkitAudioContext;
        let audioCtx = null;
        let audioUnlocked = false;
        if (!messagesEl || !form) {
          return;
        }
        const conversationMap = new Map();
        const cachedMessages = new Map();
        const messageIds = new Set();
        const unreadVisitors = new Set();
        let activeVisitorId = null;
        let chatWindowOpen = false;
        let shouldStickToBottom = true;
        let eventSource = null;
        let reconnectTimer = null;
        let legacyLastMessageId = 0;

        function ensureAudioContext() {
          if (audioCtx || !AudioContext) {
            return !!audioCtx;
          }
          try {
            audioCtx = new AudioContext();
          } catch (error) {
            console.warn("Unable to initialize audio context", error);
          }
          return !!audioCtx;
        }

        function unlockAudioContext() {
          if (audioUnlocked || !ensureAudioContext()) {
            return;
          }
          if (audioCtx.state === "suspended") {
            audioCtx.resume();
          }
          audioUnlocked = true;
        }

        function playNotificationSound() {
          if (!ensureAudioContext()) return;
          if (audioCtx.state === "suspended" && audioUnlocked) {
            audioCtx.resume();
          }
          try {
            const oscillator = audioCtx.createOscillator();
            const gainNode = audioCtx.createGain();
            oscillator.type = "sine";
            oscillator.frequency.value = 880;
            gainNode.gain.value = 0.0001;
            oscillator.connect(gainNode);
            gainNode.connect(audioCtx.destination);
            const now = audioCtx.currentTime;
            gainNode.gain.exponentialRampToValueAtTime(0.15, now + 0.02);
            gainNode.gain.exponentialRampToValueAtTime(0.00001, now + 0.35);
            oscillator.start(now);
            oscillator.stop(now + 0.4);
          } catch (error) {
            console.warn("Unable to play notification sound", error);
          }
        }

        function formatConversationLabel(meta) {
          if (!meta || !meta.visitor_id) {
            return "Unknown visitor";
          }
          const shortId = meta.visitor_id.slice(0, 6).toUpperCase();
          const ip = meta.ip_address && meta.ip_address !== "Unknown" ? meta.ip_address : null;
          return ip ? `${ip} (${shortId})` : `Visitor ${shortId}`;
        }

        function updateConversationSelect() {
          if (!conversationSelect) return;
          const previousValue = conversationSelect.value;
          conversationSelect.innerHTML = "";
          if (!conversationMap.size) {
            const option = document.createElement("option");
            option.value = "";
            option.textContent = "No conversations yet";
            conversationSelect.appendChild(option);
            conversationSelect.disabled = true;
          } else {
            conversationSelect.disabled = false;
            Array.from(conversationMap.values())
              .sort((a, b) => {
                const aDate = new Date(a.created_at || 0).getTime();
                const bDate = new Date(b.created_at || 0).getTime();
                return bDate - aDate;
              })
              .forEach((meta) => {
                if (!meta || !meta.visitor_id) return;
                const option = document.createElement("option");
                option.value = meta.visitor_id;
                option.textContent = formatConversationLabel(meta);
                if (unreadVisitors.has(meta.visitor_id)) {
                  option.textContent += " • New";
                }
                conversationSelect.appendChild(option);
              });
          }
          if (previousValue && conversationMap.has(previousValue)) {
            conversationSelect.value = previousValue;
          } else if (activeVisitorId) {
            conversationSelect.value = activeVisitorId;
          } else {
            conversationSelect.value = "";
          }
        }

        function ensureConversationMeta(visitorId, ipAddress) {
          if (!visitorId) return;
          const existing = conversationMap.get(visitorId) || {};
          const merged = Object.assign({}, existing, {
            visitor_id: visitorId,
            ip_address: ipAddress || existing.ip_address || "Unknown",
          });
          merged.created_at = merged.created_at || new Date().toISOString();
          merged.message_count = (cachedMessages.get(visitorId) || []).length;
          conversationMap.set(visitorId, merged);
        }

        function markCachedMessagesAsRead(visitorId) {
          const messages = cachedMessages.get(visitorId);
          if (!messages) return;
          messages.forEach((msg) => {
            if (msg.sender === "visitor") {
              msg.seen_by_admin = true;
            }
          });
        }

        function renderPlaceholder(text) {
          const placeholder = document.createElement("div");
          placeholder.className = "chat-empty-state";
          placeholder.textContent = text;
          messagesEl.appendChild(placeholder);
        }

        function renderMessage(message) {
          const row = document.createElement("div");
          row.className = `chat-row ${message.sender}`;
          const bubble = document.createElement("div");
          bubble.className = "bubble";
          bubble.textContent = message.body;
          row.appendChild(bubble);
          messagesEl.appendChild(row);
          if (shouldStickToBottom) {
            messagesEl.scrollTop = messagesEl.scrollHeight;
          }
        }

        function renderAllMessages() {
          messagesEl.innerHTML = "";
          if (!activeVisitorId || !cachedMessages.has(activeVisitorId)) {
            renderPlaceholder("Select a visitor conversation to get started.");
            return;
          }
          const messages = cachedMessages.get(activeVisitorId).slice().sort((a, b) => a.id - b.id);
          if (!messages.length) {
            renderPlaceholder("No messages yet. Say hello to the visitor!");
            return;
          }
          messages.forEach((msg) => renderMessage(msg));
          messagesEl.scrollTop = messagesEl.scrollHeight;
        }

        function updateStickToBottom() {
          const { scrollTop, scrollHeight, clientHeight } = messagesEl;
          const distanceFromBottom = scrollHeight - (scrollTop + clientHeight);
          shouldStickToBottom = distanceFromBottom <= 40;
        }

        messagesEl.addEventListener("scroll", updateStickToBottom);

        function setIndicator(state, waitingCount = unreadVisitors.size) {
          if (!indicator) return;
          indicator.classList.toggle("active", state);
          if (!state) {
            indicator.textContent = "All caught up";
          } else if (waitingCount === 1) {
            indicator.textContent = "1 visitor waiting";
          } else {
            indicator.textContent = `${waitingCount} visitors waiting`;
          }
        }

        function setFlash(state) {
          if (!chatAlert) return;
          if (state && !chatWindowOpen) {
            chatAlert.classList.add("flash");
          } else {
            chatAlert.classList.remove("flash");
          }
        }

        function updateChatStatus(waitingCount) {
          if (statusMessage) {
            if (!conversationMap.size) {
              statusMessage.textContent = "No live conversations yet.";
            } else if (waitingCount > 1) {
              statusMessage.textContent = `There are ${waitingCount} visitors waiting to chat.`;
            } else if (waitingCount === 1) {
              statusMessage.textContent = "A visitor is waiting to chat.";
            } else if (chatWindowOpen) {
              statusMessage.textContent = "Chat window is open.";
            } else {
              statusMessage.textContent = "No visitors are currently waiting.";
            }
          }
          if (openButton) {
            if (!conversationMap.size) {
              openButton.disabled = true;
              openButton.textContent = "Open chat window";
            } else if (chatWindowOpen) {
              openButton.disabled = true;
              openButton.textContent = "Chat window open";
            } else {
              openButton.disabled = false;
              openButton.textContent = waitingCount ? "Respond to visitor" : "Open chat window";
            }
          }
          setFlash(waitingCount > 0);
        }

        function updateWaitingState() {
          const waitingCount = unreadVisitors.size;
          setIndicator(waitingCount > 0, waitingCount);
          updateChatStatus(waitingCount);
          updateConversationSelect();
        }

        function updateFormState() {
          const hasActive = !!activeVisitorId && conversationMap.has(activeVisitorId);
          if (input) {
            input.disabled = !hasActive;
          }
          if (submitButton) {
            submitButton.disabled = !hasActive;
          }
          if (deleteButton) {
            deleteButton.disabled = !hasActive;
          }
        }

        function addMessageToCache(message, fromHistory = false) {
          if (!message || messageIds.has(message.id)) {
            return;
          }
          const visitorId = message.visitor_id;
          if (!cachedMessages.has(visitorId)) {
            cachedMessages.set(visitorId, []);
          }
          cachedMessages.get(visitorId).push(message);
          messageIds.add(message.id);
          legacyLastMessageId = Math.max(legacyLastMessageId, message.id);
          ensureConversationMeta(visitorId, message.visitor_ip);
          if (!fromHistory && message.sender === "visitor" && !message.seen_by_admin) {
            unreadVisitors.add(visitorId);
            if (!chatWindowOpen || visitorId !== activeVisitorId) {
              playNotificationSound();
            }
          }
          if (chatWindowOpen && visitorId === activeVisitorId && !fromHistory) {
            renderMessage(message);
          }
        }

        function handleNewMessage(message) {
          addMessageToCache(message);
          if (!activeVisitorId) {
            activeVisitorId = message.visitor_id;
            updateFormState();
            renderAllMessages();
          } else if (chatWindowOpen && message.visitor_id === activeVisitorId) {
            shouldStickToBottom = true;
          }
          if (chatWindowOpen && message.visitor_id === activeVisitorId) {
            markAsRead();
          }
          updateWaitingState();
        }

        function handleHistory(payload) {
          const messages = Array.isArray(payload.messages) ? payload.messages : [];
          cachedMessages.clear();
          messageIds.clear();
          messages
            .slice()
            .sort((a, b) => a.id - b.id)
            .forEach((msg) => addMessageToCache(msg, true));
          if (Array.isArray(payload.conversations)) {
            conversationMap.clear();
            unreadVisitors.clear();
            payload.conversations.forEach((conversation) => {
              if (!conversation || !conversation.visitor_id) return;
              conversationMap.set(conversation.visitor_id, conversation);
              if (conversation.unread) {
                unreadVisitors.add(conversation.visitor_id);
              }
            });
          }
          if (!activeVisitorId) {
            const firstUnread = unreadVisitors.values().next().value;
            if (firstUnread) {
              activeVisitorId = firstUnread;
            } else {
              const firstConversation = conversationMap.keys().next().value;
              activeVisitorId = firstConversation || null;
            }
          }
          renderAllMessages();
          updateFormState();
          updateWaitingState();
        }

        function removeConversationFromState(visitorId) {
          if (!visitorId) return;
          cachedMessages.delete(visitorId);
          conversationMap.delete(visitorId);
          unreadVisitors.delete(visitorId);
          if (activeVisitorId === visitorId) {
            activeVisitorId = conversationMap.keys().next().value || null;
          }
          if (!conversationMap.size) {
            closeChatWindow();
          }
          updateFormState();
          renderAllMessages();
          updateWaitingState();
        }

        function handleConversationDeleted(visitorId) {
          removeConversationFromState(visitorId);
        }

        async function markAsRead(force = false) {
          if (!activeVisitorId) return;
          if (!unreadVisitors.has(activeVisitorId) && !force) {
            return;
          }
          unreadVisitors.delete(activeVisitorId);
          markCachedMessagesAsRead(activeVisitorId);
          updateWaitingState();
          try {
            await fetch("/admin/chat/read", {
              method: "POST",
              headers: { "Content-Type": "application/json" },
              body: JSON.stringify({ visitor_id: activeVisitorId }),
            });
          } catch (error) {
            console.error("Unable to mark chat as read", error);
          }
        }

        function handleStreamPayload(payload) {
          if (!payload) return;
          if (payload.type === "ping") {
            return;
          }
          if (payload.type === "history") {
            handleHistory(payload);
            return;
          }
          if (payload.type === "message" && payload.message) {
            handleNewMessage(payload.message);
            return;
          }
          if (payload.type === "conversation_deleted") {
            handleConversationDeleted(payload.visitor_id);
          }
        }

        function disconnectStream() {
          if (eventSource) {
            eventSource.close();
            eventSource = null;
          }
          if (reconnectTimer) {
            clearTimeout(reconnectTimer);
            reconnectTimer = null;
          }
        }

        function connectStream() {
          if (!window.EventSource || eventSource) {
            return;
          }
          eventSource = new EventSource("/chat/stream?role=admin");
          eventSource.onmessage = (event) => {
            try {
              const payload = JSON.parse(event.data);
              handleStreamPayload(payload);
            } catch (error) {
              console.error("Unable to parse chat update", error);
            }
          };
          eventSource.onerror = () => {
            disconnectStream();
            reconnectTimer = setTimeout(connectStream, 2000);
          };
        }

        function getDefaultVisitor() {
          const firstUnread = unreadVisitors.values().next().value;
          if (firstUnread) return firstUnread;
          return conversationMap.keys().next().value || null;
        }

        function openChatWindow() {
          if (!panel || !conversationMap.size) return;
          chatWindowOpen = true;
          panel.classList.remove("hidden");
          if (!activeVisitorId) {
            activeVisitorId = getDefaultVisitor();
          }
          shouldStickToBottom = true;
          renderAllMessages();
          updateFormState();
          updateWaitingState();
          setFlash(false);
          markAsRead(true);
        }

        function closeChatWindow() {
          if (!panel) return;
          chatWindowOpen = false;
          panel.classList.add("hidden");
          updateWaitingState();
        }

        const unlockEvents = [openButton, closeButton, form];
        unlockEvents.forEach((element) => {
          if (!element) return;
          const eventName = element === form ? "submit" : "click";
          element.addEventListener(eventName, unlockAudioContext, { once: true });
        });

        window.addEventListener(
          "pointerdown",
          () => {
            unlockAudioContext();
          },
          { once: true }
        );

        if (openButton) {
          openButton.addEventListener("click", openChatWindow);
        }

        if (closeButton) {
          closeButton.addEventListener("click", closeChatWindow);
        }

        if (conversationSelect) {
          conversationSelect.addEventListener("change", (event) => {
            const value = event.target.value;
            activeVisitorId = value || null;
            shouldStickToBottom = true;
            renderAllMessages();
            updateFormState();
            if (chatWindowOpen) {
              markAsRead();
            }
          });
        }

        if (deleteButton) {
          deleteButton.addEventListener("click", async () => {
            if (!activeVisitorId) return;
            const confirmed = window.confirm("Delete this conversation? This cannot be undone.");
            if (!confirmed) return;
            try {
              await fetch(`/admin/chat/${encodeURIComponent(activeVisitorId)}/delete`, {
                method: "POST",
              });
            } catch (error) {
              console.error("Unable to delete conversation", error);
            }
            removeConversationFromState(activeVisitorId);
          });
        }

        form.addEventListener("submit", async (event) => {
          event.preventDefault();
          if (!activeVisitorId) return;
          const value = input.value.trim();
          if (!value) return;
          try {
            const response = await fetch("/chat/messages", {
              method: "POST",
              headers: { "Content-Type": "application/json" },
              body: JSON.stringify({ sender: "admin", body: value, visitor_id: activeVisitorId }),
            });
            if (response.ok) {
              const message = await response.json();
              input.value = "";
              shouldStickToBottom = true;
              handleNewMessage(message);
              markAsRead();
            }
          } catch (error) {
            console.error("Unable to send chat response", error);
          }
        });

        if (panel) {
          panel.addEventListener("click", () => markAsRead());
          panel.addEventListener("mouseenter", () => markAsRead());
        }

        async function loadInitialHistory() {
          try {
            const response = await fetch(`/chat/messages?role=admin`, { cache: "no-store" });
            if (!response.ok) return;
            const data = await response.json();
            handleHistory(data);
          } catch (error) {
            console.error("Unable to load chat messages", error);
          }
        }

        async function legacyPoll() {
          try {
            const response = await fetch(`/chat/messages?role=admin&after=${legacyLastMessageId}`, {
              cache: "no-store",
            });
            if (!response.ok) return;
            const data = await response.json();
            if (Array.isArray(data.messages)) {
              data.messages.forEach((msg) => handleNewMessage(msg));
            }
          } catch (error) {
            console.error("Unable to load chat messages", error);
          }
        }

        function bootstrapConversations() {
          if (Array.isArray(initialConversations)) {
            initialConversations.forEach((conversation) => {
              if (!conversation || !conversation.visitor_id) return;
              conversationMap.set(conversation.visitor_id, conversation);
              if (conversation.unread) {
                unreadVisitors.add(conversation.visitor_id);
              }
            });
          }
          activeVisitorId = getDefaultVisitor();
          updateFormState();
          updateWaitingState();
        }

        bootstrapConversations();

        if (window.EventSource) {
          connectStream();
          window.addEventListener("beforeunload", disconnectStream);
        } else {
          console.warn("EventSource not available; using fallback polling");
          loadInitialHistory().finally(() => {
            legacyPoll();
            setInterval(legacyPoll, 4000);
          });
        }
      })();
    </script>

  </body>
</html>
